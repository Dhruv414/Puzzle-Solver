# -*- coding: utf-8 -*-
"""dienpuzzle_sample_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TXkEtp13xUAS03bS6MqU6vQjZwjIwjpN
"""

# DO NOT RENAME THIS FILE
# This file enables automated judging
# This file should stay named as `submission.py`

# Import Python Libraries
import numpy as np
from glob import glob
from PIL import Image
from itertools import permutations
from keras.models import load_model
from tensorflow.keras.utils import load_img, img_to_array

# Import helper functions from utils.py
import utils

class Predictor:
    """
    DO NOT RENAME THIS CLASS
    This class enables automated judging
    This class should stay named as `Predictor`
    """

    def __init__(self):
        """
        Initializes any variables to be used when making predictions
        """
        self.model = load_model('/content/drive/MyDrive/Datathon/example_model.h5')

    def make_prediction(self, img_path):
        """
        DO NOT RENAME THIS FUNCTION
        This function enables automated judging
        This function should stay named as `make_prediction(self, img_path)`

        INPUT:
            img_path: 
                A string representing the path to an RGB image with dimensions 128x128
                example: `example_images/1.png`
        
        OUTPUT:
            A 4-character string representing how to re-arrange the input image to solve the puzzle
            example: `3120`
        """

        # Load the image
        img = load_img(f'{img_path}', target_size=(128, 128))

        # Converts the image to a 3D numpy array (128x128x3)
        img_array = img_to_array(img)

        # Convert from (128x128x3) to (Nonex128x128x3), for tensorflow
        img_tensor = np.expand_dims(img_array, axis=0)

        # Preform a prediction on this image using a pre-trained model (you should make your own model :))
        prediction = self.model.predict(img_tensor, verbose=False)

        # The example model was trained to return the percent chance that the input image is scrambled using 
        # each one of the 24 possible permutations for a 2x2 puzzle
        combs = [''.join(str(x) for x in comb) for comb in list(permutations(range(0, 4)))]

        # Return the combination that the example model thinks is the solution to this puzzle
        # Example return value: `3120`
        return combs[np.argmax(prediction)]

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

# Example main function for testing/development
# Run this file using `python3 submission.py`
for img_name in glob('/content/drive/MyDrive/Datathon/example_images/*'):
    # Open an example image using the PIL library
    example_image = Image.open(img_name)

    # Use instance of the Predictor class to predict the correct order of the current example image
    predictor = Predictor()
    prediction = predictor.make_prediction(img_name)
    # Example images are all shuffled in the "3120" order
    print(prediction)

    # Visualize the image
    pieces = utils.get_uniform_rectangular_split(np.asarray(example_image), 2, 2)
    # Example images are all shuffled in the "3120" order
    final_image = Image.fromarray(np.vstack((np.hstack((pieces[3],pieces[1])),np.hstack((pieces[2],pieces[0])))))
    display(final_image)

"""# Crossvalidation Pipeline"""

from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, confusion_matrix, classification_report

# !unzip train.zip -d "/content/drive/MyDrive/Datathon/train"

train_data_path = "/content/drive/MyDrive/Datathon/train/*"
size = 50000
X = np.array([""]*size, dtype=object) # 50000 - # of training samples
y = np.array([""]*size, dtype=object)

i = 0
for permutation_folder in glob(train_data_path):
  permutation = permutation_folder[-4:]
  for file_path in glob(permutation_folder+"/*"):
    X[i] = file_path # /content/drive/MyDrive/Datathon/train/2031/00000.png
    y[i] = permutation # 2031
    i += 1

def calculate_accuracy(predictions, labels):
  return sum(p == l for p, l in zip(predictions, labels)) / len(labels)

# StratifiedKFold used because 
sfk = StratifiedKFold(n_splits=5, shuffle=True, random_state = 1) # random_state for reproducibility
for train, test in sfk.split(X, y):
  # X holds the file_paths, y is the file_folder they're in(true permutation)

  model_fit = model.fit(X[train], y[train])
  pred_y = model_fit.predict(X[test]) # Assuming this prediction returns array containing strings of permutation
  print(calculate_accuracy(pred_y, y[test]))
